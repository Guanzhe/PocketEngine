//
//  ScriptWorld.cpp
//  ComponentSystem
//
//  Created by Jeppe Nielsen on 10/02/16.
//  Copyright Â© 2016 Jeppe Nielsen. All rights reserved.
//

#include "ScriptWorld.hpp"
#include <dlfcn.h>
#include <set>
#include <iostream>
#include <stdio.h>
#include "FileReader.hpp"
#include "StringHelper.hpp"
#include "FileHelper.hpp"

using namespace std;
using namespace Pocket;

ScriptWorld::ScriptWorld() : libHandle(0), baseSystemIndex(-1) {
    Types.Add<bool>();
    Types.Add<int>();
    Types.Add<float>();
    Types.Add<double>();
    Types.Add<std::string>();
}

string ScriptWorld::ExtractHeaderPath(const std::string &headerFile) {
    size_t lastPath = headerFile.rfind("/");
    return headerFile.substr(0, lastPath);
}

string ScriptWorld::ExtractHeaderName(const std::string &headerFile) {
    size_t lastPath = headerFile.rfind("/");
    return headerFile.substr(lastPath + 1, headerFile.size() - lastPath - 1);
}

void ScriptWorld::SetClangSdkPath(const std::string& clangSdkPath) {
    this->clangSdkPath = clangSdkPath;
}

void ScriptWorld::SetFiles(const std::string& dynamicLibPath, const std::string& scriptingIncludeDir, const std::vector<std::string> &sourceFiles, const std::vector<std::string> &headerFiles) {
    
    this->sourceFiles.clear();
    this->headerNames.clear();
    this->headerPaths.clear();
    
    this->dynamicLibPath = dynamicLibPath;
    this->scriptingIncludeDir = scriptingIncludeDir;
    this->sourceFiles = sourceFiles;
    this->headerFiles = headerFiles;
    
    for(auto& header : headerFiles) {
        headerNames.push_back(ExtractHeaderName(header));
    }
    
    //header paths
    {
        std::set<std::string> uniqueHeaderPaths;
        
        uniqueHeaderPaths.insert("-I" + scriptingIncludeDir);
        for(auto& header : headerFiles) {
            uniqueHeaderPaths.insert("-I" + ExtractHeaderPath(header));
        }
        
        for(auto& source : sourceFiles) {
            uniqueHeaderPaths.insert("-I" + ExtractHeaderPath(source));
        }
        
        for(auto& uniqueHeader : uniqueHeaderPaths) {
            headerPaths.push_back(uniqueHeader);
        }
    }
    
    /*
    std::cout << "headerPaths : "<<std::endl;
    for(auto& s : headerPaths) {
        std::cout << s << std::endl;
    }
    
    std::cout << "headerNames : "<<std::endl;
    for(auto& s : headerNames) {
        std::cout << s << std::endl;
    }
    */
}

void ScriptWorld::Build(bool enableOutput, const std::string &pathToPocketEngineLib, const std::function<void(const Error&)>& onError) {
//    UnloadLib();
    std::string mainCppFile = scriptingIncludeDir + "/scriptWorld_autogenerated.cpp";
    ExtractScriptClasses();
    
    WriteMainCppFile(mainCppFile);
    
    WriteExecutableTypeInfos(scriptingIncludeDir + "/executable_autogenerated.hpp");
    
    string compilerPath = clangSdkPath + "bin/clang++";
    string compilerFlags = "-framework Foundation -dynamiclib -std=c++11 "+pathToPocketEngineLib+" -stdlib=libc++ -g";
    if (enableOutput) {
        compilerFlags += " -v";
    }
    string outputFile = "-o " + dynamicLibPath;
    
    string compilerArgs = compilerPath + " " + compilerFlags + " ";
    //compilerArgs += "-I"+clangSdkPath+"/include/c++/v1/ ";
    
    for(auto& header : headerPaths) {
        compilerArgs += header + " ";
    }
    
    for(auto& source : sourceFiles) {
        compilerArgs += source + " ";
    }
    
    compilerArgs += " ";
    
    compilerArgs += mainCppFile + " ";
    compilerArgs += outputFile;
    //compilerArgs += " > output.txt 2>&1";
    
    if (enableOutput) {
        std::cout << compilerArgs << std::endl;
    }
    
    //remove old library file
    FileReader::RunCommmand("rm " + dynamicLibPath);
    
    //remove old library dSYM folder
    std::string dsymFile = dynamicLibPath + ".dSYM";
    FileReader::RunCommmand("rm -r " + dsymFile);
    
    auto out = FileReader::RunCommmand(compilerArgs);
    
    if (enableOutput) {
        for(auto s : out) {
            std::cout << s << std::endl;
        }
    }
    
    CheckForErrors("output.txt", [&onError] (auto& error) {
        onError(error);
    //    std::cout << "Error: "<<FileHelper::GetFileNameFromPath(error.filename) << " : "<<error.lineNo << " : "<< error.description << std::endl;
    });
    
    //return LoadLib();
}

void ScriptWorld::CheckForErrors(const std::string &file, const std::function<void (const Error &)> &onError) {
    Error error;
    FileReader::ParseFile(file, [&, this] (const std::string& line){
        for(auto& h : headerFiles) {
            if (TryParseError(h, line, error)) {
                onError(error);
            }
        }
        for(auto& s : sourceFiles) {
            if (TryParseError(s, line, error)) {
                onError(error);
            }
        }
    });
}

bool ScriptWorld::TryParseError(const std::string& codeFile, const std::string& line, Error& error) {
    size_t found = line.find(codeFile);
    if (found == std::string::npos) return false;
    
    size_t lineNo = found + codeFile.size() + 1;
    size_t column = line.find(":", lineNo);
    size_t columnEnd = line.find(":", column+1);
    size_t errorEnd = line.find(":", columnEnd+1);
    
    
    if (lineNo!=std::string::npos &&
        column!=std::string::npos &&
        columnEnd!=std::string::npos &&
        errorEnd!=std::string::npos) {
    
        std::string lineNoStr = line.substr(lineNo, column - lineNo);
        std::string columnStr = line.substr(column+1, columnEnd - column-1);
        
        
        
        //std::cout << lineNoStr << std::endl;
        //std::cout << columnStr << std::endl;
        //std::cout << errorStr << std::endl;
        
        error.filename = codeFile;
        error.lineNo = ::atoi(lineNoStr.c_str());
        error.lineColumn = ::atoi(columnStr.c_str());
        
        error.type = line.substr(columnEnd+1, errorEnd - columnEnd-1);
        error.description = line.substr(errorEnd+1, line.size() - errorEnd-1);
        
        return true;
    }
    return false;
}

bool ScriptWorld::BuildExecutable(const std::string &pathToPocketEngineLib, const std::string& outputPath, const std::function<void(std::string&)>& customCode, const std::function<void(const std::string&)>& onOutput) {

    //std::string mainCppFile = scriptingIncludeDir + "/scriptWorld_autogenerated.cpp";
    ExtractScriptClasses();
    
    //WriteMainCppFile(mainCppFile);
    
    std::string exeMainCpp = "main.cpp";
    
    //WriteExecutableTypeInfos(scriptingIncludeDir + "/executable_autogenerated.hpp");
    
    WriteExecutableMain(exeMainCpp, customCode);
    
    //return false;
    
    string compilerPath = clangSdkPath + "bin/clang++";
    
    // -std=c++11 -stdlib=libc++ -DOSX libPocketEngine.a -o game -O3 -x objective-c++ -arch x86_64 -lobjc \
\
 -framework Foundation \
 -framework OpenGL \
 -framework IOKit \
 -framework Cocoa \
\

    
    string compilerFlags = "-std=c++14 -stdlib=libc++ -DOSX "+pathToPocketEngineLib+" -o " + outputPath + " -x objective-c++ -arch x86_64 -lobjc ";
    compilerFlags += "-framework Foundation -framework OpenGL -framework IOKit -framework Cocoa ";
    compilerFlags += " " + exeMainCpp;
    compilerFlags += " -v ";
    std::string POCKET_PATH=" -I /Projects/PocketEngine/Pocket/";
    
    compilerFlags += POCKET_PATH + "ComponentSystem";
    compilerFlags += POCKET_PATH + "ComponentSystem/Meta";
    compilerFlags += POCKET_PATH + "OpenGL";
    compilerFlags += POCKET_PATH + "Math";
    compilerFlags += POCKET_PATH + "Data";
    compilerFlags += POCKET_PATH + "Core";
    compilerFlags += POCKET_PATH + "Platform/OSX";
    compilerFlags += POCKET_PATH + "Serialization";
    
    compilerFlags += POCKET_PATH + "Logic/Animation";
    compilerFlags += POCKET_PATH + "Logic/Audio";
    compilerFlags += POCKET_PATH + "Logic/Common";
    compilerFlags += POCKET_PATH + "Logic/Editor";
    compilerFlags += POCKET_PATH + "Logic/Effects";
    compilerFlags += POCKET_PATH + "Logic/Gui";
    compilerFlags += POCKET_PATH + "Logic/Gui/Layout";
    compilerFlags += POCKET_PATH + "Logic/Gui/Menu";
    
    compilerFlags += POCKET_PATH + "Logic/Interaction";
    
    compilerFlags += POCKET_PATH + "Logic/Movement";
    compilerFlags += POCKET_PATH + "Logic/Physics";
    compilerFlags += POCKET_PATH + "Logic/Rendering";
    compilerFlags += POCKET_PATH + "Logic/Selection";
    compilerFlags += POCKET_PATH + "Logic/Spatial";
    compilerFlags += POCKET_PATH + "Logic/Cloning";
    compilerFlags += POCKET_PATH + "Logic/Switching";
    compilerFlags += POCKET_PATH + "Logic/Assets";
    compilerFlags += POCKET_PATH + "Logic/Input";
    compilerFlags += POCKET_PATH + "Logic/Switching";
    compilerFlags += POCKET_PATH + "Logic/Triggering";
    compilerFlags += POCKET_PATH + "Logic/Scenes";
    
    
    compilerFlags += POCKET_PATH + "Rendering/";
    compilerFlags += POCKET_PATH + "Libs/Zip";
    compilerFlags += POCKET_PATH + "Libs/STBImage";
    compilerFlags += POCKET_PATH + "Libs/FreeType/Include";
    compilerFlags += POCKET_PATH + "Libs/TinyXml";
    
    for(auto& header : headerPaths) {
        compilerFlags += " " + header;
    }
    
    for(auto& sourceFile : sourceFiles) {
        compilerFlags += " " + sourceFile;
    }
    compilerFlags += " ";
    
    
    string compilerArgs = compilerPath + " " + compilerFlags + " > output 2>&1 ";
    
    auto out = FileReader::RunCommmand(compilerArgs);

    for(auto s : out) {
        if (onOutput!=nullptr) {
            onOutput(s);
        }
        std::cout << s << std::endl;
    }
    
    //FileReader::RunCommmand(("./game");
    
    std::cout << "Build completed..."<<std::endl;
    
    return true;
}


bool ScriptWorld::LoadLib() {
    
    libHandle = dlopen(dynamicLibPath.c_str(), RTLD_LAZY);
    
    if (!libHandle) {
        cerr << "Cannot open '" << dynamicLibPath << "' library: " << dlerror() << '\n';
        return false;
    }

    createSystem = (CreateSystem)dlsym(libHandle, "CreateSystem");
    const char *dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'CreateSystem': " << dlsym_error << '\n';
        UnloadLib();
        return false;
    }
    
    countSystems = (CountSystems) dlsym(libHandle, "CountSystems");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'CountSystems': " << dlsym_error << '\n';
        UnloadLib();
        return false;
    }
    
    deleteSystem = (DeleteSystem) dlsym(libHandle, "DeleteSystem");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'DeleteSystem': " << dlsym_error << '\n';
        UnloadLib();
        return false;
    }
    
    createComponent = (CreateComponent) dlsym(libHandle, "CreateComponent");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'CreateComponent': " << dlsym_error << '\n';
        dlclose(libHandle);
        return false;
    }
    
    countComponents = (CountComponents) dlsym(libHandle, "CountComponents");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'CountComponents': " << dlsym_error << '\n';
        dlclose(libHandle);
        return false;
    }
    
    deleteComponent = (DeleteComponent) dlsym(libHandle, "DeleteComponent");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'DeleteComponent': " << dlsym_error << '\n';
        dlclose(libHandle);
        return false;
    }
    
    resetComponent = (ResetComponent) dlsym(libHandle, "ResetComponent");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'ResetComponent': " << dlsym_error << '\n';
        dlclose(libHandle);
        return false;
    }
    
    getTypeInfo = (GetTypeInfoFunction) dlsym(libHandle, "GetTypeInfo");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'GetTypeInfo': " << dlsym_error << '\n';
        dlclose(libHandle);
        return false;
    }
    
    deleteTypeInfo = (DeleteTypeInfo) dlsym(libHandle, "DeleteTypeInfo");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'DeleteTypeInfo': " << dlsym_error << '\n';
        dlclose(libHandle);
        return false;
    }
    
    return true;
}

void ScriptWorld::UnloadLib() {
    if (!libHandle) return;
    dlclose(libHandle);
}

void ScriptWorld::ExtractScriptClasses() {
    data.Clear();
    data.Parse(sourceFiles, headerPaths, [this](auto& componentName) {
        for(auto& w : worldComponentNames) {
            std::string componentNameWithNamespace = "Pocket::"+w.name;
            if (componentName == componentNameWithNamespace) return false;
        }
        return true;
    });
    
    std::cout << data.components.size() << std::endl;
}

void ScriptWorld::WriteMainCppFile(const std::string &path) {
    ofstream file;
    file.open(path);
    
    WriteMainGameObject(file);
    WriteMainIncludes(file);
    WriteTypes(file);
    WriteMainSystems(file);
    WriteMainComponents(file);
    WriteMainSerializedComponents(file);
    
    file.close();
}

void ScriptWorld::WriteMainIncludes(std::ofstream &file) {

    //file<<"namespace Pocket { class IGameSystem; }"<<std::endl;
    
    //auto& components = data.components;
    //auto& systems = data.systems;
    
    //std::set<std::string> uniqueIncludes;

    //for(auto sf : sourceFiles) {
    //    uniqueIncludes.insert(ExtractHeaderName(sf));
    //}
    
    /*for(auto& component : components) {
        uniqueIncludes.insert(component.sourceFile);
    }
    for(auto& system : systems) {
        uniqueIncludes.insert(system.second.sourceFile);
    }*/
    
    file<<"#include \"TypeInfo.hpp\""<<std::endl;
    
    for(auto& headerName : headerNames) {
        file<<"#include \""<<headerName<<"\""<<std::endl;
    }
    
    
    /*for(auto& sourceFile : sourceFiles) {
        file << "#include \"" << sourceFile << "\""<< std::endl;
    }
    */
    
    //for(auto& include : uniqueIncludes) {
        //file << "#include \"" << include << "\""<< std::endl;
    //}
    file<<std::endl;
    
}

void ScriptWorld::WriteMainGameObject(std::ofstream &file) {
    
    const std::string namespaceName = "Pocket::";

    auto& scriptComponents = data.components;
    
    file<<"namespace Pocket {"<<std::endl;
    for(auto& componentName : worldComponentNames) {
        file << "struct "<< componentName.name << ";"<<std::endl;
    }
    file<<"}"<<std::endl;
    
    //file<<"using namespace Pocket;"<<std::endl;
    
        
    for (auto& component : scriptComponents) {
        auto namespaceIndex = component.name.find("::");
        if (namespaceIndex == std::string::npos) {
            file << "struct "<< component.name << ";"<<std::endl;
        } else {
            std::string nameSpace = component.name.substr(0, namespaceIndex);
            std::string nameWithoutNamespace = component.name.substr(namespaceIndex+2, component.name.size() - 2 - namespaceIndex);
            file << "namespace "<<nameSpace<<" {" << std::endl;
            file << "   struct "<<nameWithoutNamespace << ";"<< std::endl;
            file << "}"<< std::endl;
        }
    }
    
    file << std::endl;
    
    file << "#include \"GameSystem.hpp\""<<std::endl;
    
    /*
    file << "namespace Pocket {"<<std::endl;
    file << "class GameObject {"<<std::endl;
    file << "private:"<<std::endl;
    file << "    virtual void* GetComponent(int componentID) = 0;"<<std::endl;
    file << "    virtual void AddComponent(int componentID) = 0;"<<std::endl;
    file << "    virtual void AddComponent(int componentID, GameObject* referenceObject) = 0;"<<std::endl;
    file << "    virtual void RemoveComponent(int componentID) = 0;"<<std::endl;
    file << "    virtual void CloneComponent(int componentID, GameObject* source) = 0;"<<std::endl;
    
    file << "public:" << std::endl;
    file << "    template<typename T> T* GetComponent() { return (T*)0; }"<<std::endl;
    file << "    template<typename T> T* AddComponent() { }"<<std::endl;
    file << "    template<typename T> void RemoveComponent() { }"<<std::endl;
    file << "    template<typename T> T* CloneComponent(GameObject* source) { }"<<std::endl;
    file << "};"<<std::endl;
    file << "}"<<std::endl;
    */
    
    for(auto& componentName : worldComponentNames) {
        std::string nameWithNamespace = namespaceName + componentName.name;
        file<<"template<> " << nameWithNamespace  << "* Pocket::GameObject::GetComponent<"<< nameWithNamespace << ">() { return ("<< nameWithNamespace <<"*) GetComponent("<<componentName.index<<"); }"<<std::endl;
        
        file<<"template<> " << nameWithNamespace  << "* Pocket::GameObject::AddComponent<"<< nameWithNamespace << ">() { AddComponent("<<componentName.index<<"); return ("<< nameWithNamespace <<"*) GetComponent("<<componentName.index<<"); }"<<std::endl;
     
        file<<"template<> void Pocket::GameObject::RemoveComponent<"<< nameWithNamespace << ">() { RemoveComponent("<<componentName.index<<"); }"<<std::endl;
        
        file<<"template<> " << nameWithNamespace  << "* Pocket::GameObject::CloneComponent<"<< nameWithNamespace << ">(GameObject* source) { CloneComponent("<<componentName.index<<", source); return ("<< nameWithNamespace <<"*) GetComponent("<<componentName.index<<"); }"<<std::endl;
        
        file<<"template<> " << nameWithNamespace  << "* Pocket::GameObject::ReplaceComponent<"<< nameWithNamespace << ">(GameObject* source) { ReplaceComponent("<<componentName.index<<", source); return ("<< nameWithNamespace <<"*) GetComponent("<<componentName.index<<"); }"<<std::endl;
        
        file<<"template<> void Pocket::GameObject::EnableComponent<"<< nameWithNamespace << ">(bool enable) { EnableComponent("<<componentName.index<<", enable); }"<<std::endl;
    }
    
    int index = baseComponentIndex;
    for (auto& component : scriptComponents) {
        
        std::string aliasComponentName = component.name;
        
        //file<<"using "<<aliasComponentName<<" = "<<component.name<<";"<<std::endl;
        
        file<<"template<> " << aliasComponentName  << "* Pocket::GameObject::GetComponent<"<< aliasComponentName << ">() { return ("<< aliasComponentName <<"*) GetComponent("<<index<<"); }"<<std::endl;
        
        file<<"template<> " << aliasComponentName  << "* Pocket::GameObject::AddComponent<"<< aliasComponentName << ">() { AddComponent("<<index<<"); return ("<< aliasComponentName <<"*) GetComponent("<<index<<"); }"<<std::endl;
        
        file<<"template<> void Pocket::GameObject::RemoveComponent<"<< aliasComponentName << ">() { RemoveComponent("<<index<<"); }"<<std::endl;
        
        file<<"template<> " << aliasComponentName  << "* Pocket::GameObject::CloneComponent<"<< aliasComponentName << ">(GameObject* source) { CloneComponent("<<index<<", source); return ("<< aliasComponentName <<"*) GetComponent("<<index<<"); }"<<std::endl;
        
        file<<"template<> " << aliasComponentName  << "* Pocket::GameObject::ReplaceComponent<"<< aliasComponentName << ">(GameObject* source) { ReplaceComponent("<<index<<", source); return ("<< aliasComponentName <<"*) GetComponent("<<index<<"); }"<<std::endl;
        
        file<<"template<> void Pocket::GameObject::EnableComponent<"<< aliasComponentName << ">(bool enable) { EnableComponent("<<index<<", enable); }"<<std::endl;
        
        index++;
    }
}

void ScriptWorld::WriteMainSystems(std::ofstream &file) {
    
    auto& systems = data.systems;
    
    {
       file<<"extern \"C\" int CountSystems() {"<<std::endl;
       file<<"   return "<< systems.size() <<";"<<std::endl;
       file<<"}"<<std::endl;
    }
    
    {
        file<<"extern \"C\" IGameSystem* CreateSystem(int systemID) {"<<std::endl;
            file << "   switch (systemID) { " << std::endl;
                int index = baseSystemIndex;
                for(auto& system : systems) {
                    file<<"      case "<<index <<":"<<" return new "<<system.name<<"();"<<std::endl;
                    index++;
                }
        file<<"      default: return 0;"<<std::endl;
        file<<"   }"<<std::endl;
        file<<"}"<<std::endl;
    }
    
    {
       file<<"extern \"C\" void DeleteSystem(IGameSystem* scriptSystem) {"<<std::endl;
       file<<"   delete scriptSystem; "<<std::endl;
       file<<"}"<<std::endl;
    }
}

void ScriptWorld::WriteMainComponents(std::ofstream &file) {
    
    auto& components = data.components;

    {
       file<<"extern \"C\" int CountComponents() {"<<std::endl;
       file<<"   return "<< components.size() <<";"<<std::endl;
       file<<"}"<<std::endl;
    }
    
    {
        file<<"extern \"C\" void* CreateComponent(int componentID) {"<<std::endl;
        file << "   switch (componentID) { " << std::endl;
        int index = baseComponentIndex;
        for(auto& component : components) {
            file<<"      case "<<index <<":"<<" return new "<<component.name<<"();"<<std::endl;
            index++;
        }
        file<<"      default: return 0;"<<std::endl;
        file<<"   }"<<std::endl;
        file<<"}"<<std::endl;
    }
    
    {
       file<<"extern \"C\" void DeleteComponent(int componentID, void* component) {"<<std::endl;
        file << "   switch (componentID) { " << std::endl;
        int index = baseComponentIndex;
        for(auto& component : components) {
            file<<"      case "<<index <<":"<<" { delete (("<<component.name<<"*)component); break; }"<<std::endl;
            index++;
        }
        file<<"   }"<<std::endl;
        file<<"}"<<std::endl;
    }
    
    {
       file<<"extern \"C\" void ResetComponent(int componentID, void* c, void* s) {"<<std::endl;
            file << "   switch (componentID) { " << std::endl;
                int index = baseComponentIndex;
                for(auto& component : components) {
                    file<<"      case "<<index <<":"<<" { "<<component.name<<"* co = ("<<component.name<<"*)c; "<<std::endl;
                    file<<"      "<<component.name<<"* so = (("<<component.name<<"*)s);"<<std::endl;
                    file<<"        co->operator=(*so);             break; }"<<std::endl;
                    index++;
                }
        file<<"   }"<<std::endl;
        file<<"}"<<std::endl;
    }

    file<<std::endl;
}

void ScriptWorld::WriteMainSerializedComponents(std::ofstream &file) {

    auto& components = data.components;

    file<<"extern \"C\" Pocket::TypeInfo* GetTypeInfo(int componentID, void* componentPtr) {"<<std::endl;
        file << "   switch (componentID) { " << std::endl;
            int index = baseComponentIndex;
            for(auto& component : components) {
                file<<"      case "<<index <<": {"<<std::endl;
                file<<"      "<<component.name<<"* component = ("<<component.name<<"*)componentPtr;"<<std::endl;
                file<<"	      Pocket::TypeInfo* info = new Pocket::TypeInfo();"<<std::endl;
                file<<"	      info->name = \""<<component.name<<"\";"<<std::endl;
                std::set<std::string> uniqueFields;
                for(auto& f : component.fields) {
                    uniqueFields.insert(f.name);
                }
                
                for(auto& field : uniqueFields) {
                    file<<"	      info->AddField(component->"<< field <<", \""<<field<<"\");"<<std::endl;
                }
                file<<"      return info;"<<std::endl;
                
                file<<"      break; }"<<std::endl;
                index++;
            }
    file<<"      default: return 0;"<<std::endl;
    file<<"   }"<<std::endl;
    file<<"}"<<std::endl;

    file<<"extern \"C\" void DeleteTypeInfo(Pocket::TypeInfo* typeInfo) {"<<std::endl;
    file << "delete typeInfo;"<<std::endl;
    file<<"}"<<std::endl;
}

void ScriptWorld::WriteTypes(std::ofstream &file) {

    file << "#include <string>"<<std::endl;
    file << "#include <vector>"<<std::endl;
    file << "#include \"Property.hpp\""<<std::endl;
    auto typeNames = Types.GetTypeNames();
    
    for(auto n : typeNames) {
        file<<"template<> struct Pocket::FieldInfoIndexer<"<< n.second << "> { static int Index() { return "<< n.first << "; } };"<<std::endl;
    }
    file<<""<<std::endl;
}

#define FILE_SOURCE(...) #__VA_ARGS__

void ScriptWorld::WriteExecutableMain(const std::string &path, const std::function<void(std::string&)>& customCode) {
    
    ofstream file;
    file.open(path);
    
    file<<"#include \"Engine.hpp\""<<std::endl;
    file<<"#include \"File.hpp\""<<std::endl;
    file<<"#include \"FileArchive.hpp\""<<std::endl;
    file<<"#include \"RenderSystem.hpp\""<<std::endl;
    file<<"#include \"TransformHierarchy.hpp\""<<std::endl;
    file<<"#include \"TouchSystem.hpp\""<<std::endl;
    file<<"#include \"ClonerSystem.hpp\""<<std::endl;
    file<<"#include \"InputMapperSystem.hpp\""<<std::endl;
    file<<"#include \"VelocitySystem.hpp\""<<std::endl;
    file<<"#include \"Gui.hpp\""<<std::endl;
    file<<"#include \"SwitchSystem.hpp\""<<std::endl;
    file<<"#include \"SwitchEnablerSystem.hpp\""<<std::endl;
    file<<"#include \"TouchSwitchSystem.hpp\""<<std::endl;
    file<<"#include \"SlicedQuadMeshSystem.hpp\""<<std::endl;
    file<<"#include \"AssetManager.hpp\""<<std::endl;
    file<<"#include \"TriggerSystem.hpp\""<<std::endl;
    file<<"#include \"TriggerTouchSystem.hpp\""<<std::endl;
    file<<"#include \"SceneManagerSystem.hpp\""<<std::endl;
    
    for(auto& header : headerNames) {
        file << "#include \""<<header<<"\""<<std::endl;
    }
    
    file << FILE_SOURCE(
    
    void CreateDefaultSystems(Pocket::GameObject &world) {
        world.CreateSystem<Pocket::RenderSystem>();
        world.CreateSystem<Pocket::TransformHierarchy>();
        world.CreateSystem<Pocket::TouchSystem>()->TouchDepth = 0;
        world.CreateSystem<Pocket::ClonerSystem>();
        world.CreateSystem<Pocket::InputMapperSystem>();
        world.CreateSystem<Pocket::VelocitySystem>();
        world.CreateSystem<Pocket::Gui>();
        world.CreateSystem<Pocket::SwitchSystem>();
        world.CreateSystem<Pocket::SwitchEnablerSystem>();
        world.CreateSystem<Pocket::TouchSwitchSystem>();
        world.CreateSystem<Pocket::SlicedQuadMeshSystem>();
        world.CreateSystem<Pocket::AssetManager>();
        world.CreateSystem<Pocket::TriggerSystem>();
        world.CreateSystem<Pocket::TriggerTouchSystem>();
        world.CreateSystem<Pocket::SceneManagerSystem>();
        
    
    ) << std::endl;

    file << "}"<<std::endl;
    
    
    file << "void CreateScriptSystems(Pocket::GameObject &world) {"<<std::endl;
    
    for(auto& component : data.components) {
        
        file<<"world.World()->AddComponentTypeWithGetType<"<<component.name<<">([] (const Pocket::GameObject* object) -> Pocket::TypeInfo {"<< std::endl;
        file<<component.name<<"* component = object->GetComponent<"<<component.name<<">();"<<std::endl;
        file<< "      Pocket::TypeInfo typeInfo;"<<std::endl;
        file<<"	      typeInfo.name = \""<<component.name<<"\";"<<std::endl;
        std::set<std::string> uniqueFields;
        for(auto& f : component.fields) {
            uniqueFields.insert(f.name);
        }
        
        for(auto& field : uniqueFields) {
            file<<"	      typeInfo.AddField(component->"<< field <<", \""<<field<<"\");"<<std::endl;
        }

        file<< "return typeInfo;"<<std::endl;
        file<< "});"<<std::endl;
    }
    
    for(auto& system : data.systems) {
        file << "world.CreateSystem<"<<system.name<< ">();"<<std::endl;
    }
    
    file<< "}"<<std::endl;

    
    
        
    std::string source = FILE_SOURCE(

class GameCode : public Pocket::GameState<GameCode> {
public:
    Pocket::GameWorld world;
    Pocket::FileArchive fileArchive;
    
    void Initialize() {
    
        std::string zipFile = "resources";
    
        fileArchive.Initialize(zipFile);
        File::SetArchive(fileArchive);
        
        world.GuidToRoot = [this] (const std::string& guid) {
            GameObject* root = 0;
            if (!fileArchive.TryLoadData(guid, [&root, this] (void* data, size_t size) {
                std::stringstream ss;
                ss.write((const char*)data, size);
                root = world.CreateRootFromJson(ss, [](GameObject* root) {
                    CreateDefaultSystems(*root);
                    CreateScriptSystems(*root);
                });
            })) {
                std::cout << "unable to load: "<<guid <<std::endl;
            }
            return root;
        };
        world.GuidToPath = [] (const std::string& guid) { return guid; };

);

customCode(source);

source += FILE_SOURCE(
    }
    
    void Update(float dt) {
        Context().InputDevice().UpdateInputManager(&world.Input());
        world.Update(dt);
    }
    
    void Render() {
        world.Render();
    }
};

int main() {
    Pocket::Engine e;
    e.Start<GameCode>();
	return 0;
}
    );
    
    file << source << std::endl;
    file.close();
}


void ScriptWorld::WriteExecutableTypeInfos(const std::string &path) {
    
    ofstream file;
    file.open(path);
    
    file<<"GameWorld::OnGetTypeInfo = [] (int componentID, GameObject::ComponentInfo& info) {"<<std::endl;
        file<<" static std::map<int, std::function<TypeInfo(GameObject*)>> componentToFunction; "<<std::endl;
        file<<" if (!componentToFunction.empty()) {" <<std::endl;
    
            for(auto& component : data.components) {
                file << "componentToFunction[GameIDHelper::GetComponentID<"<<component.name<<">()] = [](GameObject* object) -> TypeInfo {"<<std::endl;
                    file<<component.name<<"* component = object->GetComponent<"<<component.name<<">();"<<std::endl;
                    file<< "TypeInfo typeInfo;"<<std::endl;
                    file<<"	      typeInfo.name = \""<<component.name<<"\";"<<std::endl;
                    std::set<std::string> uniqueFields;
                    for(auto& f : component.fields) {
                        uniqueFields.insert(f.name);
                    }
                    
                    for(auto& field : uniqueFields) {
                        file<<"	      typeInfo.AddField(component->"<< field <<", \""<<field<<"\");"<<std::endl;
                    }
            
                    file<< "return typeInfo;"<<std::endl;
                file<<"};"<<std::endl;
                
            }
        file<<"   }"<<std::endl;
    
        file<<"info.getTypeInfo = componentToFunction[componentID];"<<std::endl;
    
    file<<"};"<<std::endl;
    file.close();
}

bool ScriptWorld::FindComponentIndex(std::string componentName, bool &staticComponent, int& index) {
    {
        index = 0;
        for(auto& scriptComponent : data.components) {
            if (scriptComponent.name == componentName) {
                staticComponent = false;
                return true;
            }
            index++;
        }
    }
    
    index = -1;
    
    for(auto& worldComponentName : worldComponentNames) {
        if (componentName == worldComponentName.name) {
            index = worldComponentName.index;
            break;
        }
    }
    
    if (index>=0) {
        staticComponent = true;
        return true;
    }
    
    return false;
}

void ScriptWorld::SetWorldType(GameWorld& world, const std::function<bool(int)>& componentTypePredicate) {
    if (baseSystemIndex>=0) return;

    worldComponentNames.clear();
    for(int i=0; i<world.components.size(); ++i) {
        if (componentTypePredicate && !componentTypePredicate(i)) continue;
    
        std::string& name = world.components[i].name;
        size_t namespaceColons = name.find("::");
        std::string nameWithoutNamespace;
        if (namespaceColons!=std::string::npos) {
            nameWithoutNamespace = name.substr(namespaceColons+2, name.size() - namespaceColons-2);
        } else {
            nameWithoutNamespace = name;
        }
        if (nameWithoutNamespace!="") {
            worldComponentNames.push_back({ nameWithoutNamespace, i });
        }
    }
    
    baseComponentIndex = (int)world.components.size();
    baseSystemIndex = (int)world.systems.size();
}

bool ScriptWorld::AddGameWorld(GameWorld& world) {
    if (!libHandle) return false;
    
    scriptComponents.clear();
    
    int numberOfComponents = countComponents();
    componentCount = numberOfComponents;

    //assert(baseComponentIndex == (int)world.components.size());
    //assert(baseSystemIndex == (int)world.systems.size());
    
    
    for(int i=0; i<numberOfComponents; ++i) {
        int componentIndex = baseComponentIndex + i;
        world.AddComponentType(componentIndex, [this, componentIndex](GameWorld::ComponentInfo& componentInfo) {
            Container<ScriptComponent>* container = new Container<ScriptComponent>();
            container->defaultObject.world = this;
            container->defaultObject.componentID = componentIndex;
            container->defaultObject.data = createComponent(componentIndex);
            componentInfo.getTypeInfo = [this, componentIndex](const GameObject* object) -> TypeInfo {
                return GetTypeInfo(*object, componentIndex);
            };
            componentInfo.getFieldEditor = [this, componentIndex](GameObject* object) -> IFieldEditor* {
                IFieldEditor* editor = new TypeInfoEditor();
                TypeInfo info = GetTypeInfo(*object, componentIndex);
                editor->SetField(&info);
                return editor;
            };
            componentInfo.container = container;
            return container;
        });
        
        
        int componentNameCounter = 0;
        for(auto c : data.components) {
            if (componentNameCounter == i) {
                world.components[componentIndex].name = c.name;
                scriptComponents[c.name] = componentIndex;
            }
            componentNameCounter++;
        }
    }
    
    int index = 0;
    for (auto& scriptSystem : data.systems) {
        int systemIndex = baseSystemIndex + index;
        world.AddSystemType(systemIndex, [this, &scriptSystem, systemIndex] (GameWorld::SystemInfo& systemInfo, std::vector<ComponentId>& components) {
            
            for (auto& component : scriptSystem.components) {
                int componentIndex;
                bool staticComponent;
                if (FindComponentIndex(component, staticComponent, componentIndex)) {
                    components.push_back(staticComponent ? componentIndex : (baseComponentIndex + componentIndex));
                }
            }
            systemInfo.createFunction = [this, systemIndex] (GameObject* root) {
                IGameSystem* system = createSystem(systemIndex);
                system->SetIndex(systemIndex);
                return system;
            };
            systemInfo.deleteFunction = [this, systemIndex] (IGameSystem* system) {
                deleteSystem(system);
            };
        });
        index++;
    }
    
    
    int endComponentIndex = (int)world.components.size();
    world.objects.Iterate([endComponentIndex](GameObject* o) {
        o->activeComponents.Resize(endComponentIndex);
        o->enabledComponents.Resize(endComponentIndex);
    });

    return true;
}

void ScriptWorld::AddGameRoot(Pocket::GameObject *root) {
    
    GameScene* scene = root->scene;
    
    for (int i=0; i<data.systems.size(); ++i) {
        int systemIndex = baseSystemIndex + i;
        scene->CreateSystem(systemIndex);
    }
}

void ScriptWorld::RemoveGameWorld(GameWorld& world) {
    if (baseSystemIndex == -1) return;
    int endSystemIndex = (int)world.systems.size();
    for(int i=baseSystemIndex; i<endSystemIndex; ++i){
        world.RemoveSystemType(i);
    }
    world.systems.resize(baseSystemIndex);
    int endComponentIndex = (int)world.components.size();
    for(int i=baseComponentIndex; i<endComponentIndex; ++i) {
        delete world.components[i].container;
    }
    world.components.resize(baseComponentIndex);
    world.objects.Iterate([this](GameObject* o) {
        o->activeComponents.Resize(baseComponentIndex);
        o->enabledComponents.Resize(baseComponentIndex);
    });
    world.components.resize(baseComponentIndex);
    for(int i=0; i<baseComponentIndex; ++i) {
        auto& list = world.components[i].systemsUsingComponent;
        std::remove_if(list.begin(), list.end(), [this, endSystemIndex] (int n) {
            return n>=baseSystemIndex && n<=endSystemIndex;
        });
    }
}

TypeInfo ScriptWorld::GetTypeInfo(const GameObject& object, ComponentId id) {
    void* component = object.GetComponent(id);
    if (!component) {
        return TypeInfo();
    }
    TypeInfo* info = getTypeInfo(id, component);
    TypeInfo t;
    t.UpdateFromPointer(info, Types);
    deleteTypeInfo(info);
    return t;
}

int ScriptWorld::ComponentCount() { return componentCount; }

ScriptWorld::ScriptComponents ScriptWorld::Components() {
    return scriptComponents;
}

template<> void* Container<ScriptComponent>::Get(int index) {
    return entries[index].data;
}


